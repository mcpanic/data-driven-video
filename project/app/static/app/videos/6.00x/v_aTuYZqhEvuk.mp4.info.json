{"upload_date": "20120827", "playlist": null, "description": "No description available.", "format": "18 - 360x640", "url": "http://r14---sn-ab5e6ner.c.youtube.com/videoplayback?itag=18&ip=18.111.16.106&id=693b9866a844bee9&sparams=cp%2Cid%2Cip%2Cipbits%2Citag%2Cratebypass%2Csource%2Cupn%2Cexpire&sver=3&cp=U0hXRVRTV19MTENON19MTUFFOlRMVzJnMDE2bEE0&upn=LQ8uSoE2wVE&source=youtube&fexp=939100%2C931919%2C901809%2C914020%2C916623%2C924606%2C916914%2C929117%2C929121%2C929906%2C929907%2C929922%2C929923%2C929127%2C929129%2C929131%2C929930%2C936403%2C925724%2C925726%2C936310%2C925720%2C925722%2C925718%2C936401%2C925714%2C929917%2C906945%2C929933%2C929935%2C929937%2C929939%2C939602%2C939604%2C937102%2C906842%2C913428%2C912715%2C937003%2C919811%2C932309%2C931943%2C913563%2C919373%2C930803%2C908536%2C908538%2C938701%2C931924%2C940501%2C936308%2C909549%2C900816%2C912711%2C934507%2C907231%2C936312%2C906001&expire=1380489472&key=yt1&mt=1380464096&mv=m&ipbits=8&ratebypass=yes&ms=au&signature=1FBD0EE6DBCE4852364DD17C3C4DACC2BC82E397.307C0FEAD15399956BC72F3AC4093930D1BD214E", "title": "M-600X-FA12-L5-1_100", "id": "aTuYZqhEvuk", "thumbnail": "https://i1.ytimg.com/vi/aTuYZqhEvuk/maxresdefault.jpg", "ext": "mp4", "stitle": "M-600X-FA12-L5-1_100", "extractor": "youtube", "uploader": "MITx 600x", "duration": "305", "fulltitle": "M-600X-FA12-L5-1_100", "player_url": null, "uploader_id": "600xVideo", "subtitles": {"en": "1\n00:00:00,000 --> 00:00:00,820\n\n2\n00:00:00,820 --> 00:00:03,920\nERIC GRIMSON: Now that we've\nadded functions to our\n\n3\n00:00:03,920 --> 00:00:07,150\narmamentarium of tools, we're\ngoing to see that that gives\n\n4\n00:00:07,150 --> 00:00:10,100\nus a lot of power in terms of\nthinking about computational\n\n5\n00:00:10,100 --> 00:00:11,960\nways of tackling problems.\n\n6\n00:00:11,960 --> 00:00:15,580\nFunctions give us, as we said,\nthat ability to abstract, to\n\n7\n00:00:15,580 --> 00:00:18,810\ncapture a computation and then\nwrap it up as if it were a\n\n8\n00:00:18,810 --> 00:00:22,440\nprimitive, gives the user the\nability to treat a function\n\n9\n00:00:22,440 --> 00:00:23,480\nlike a black box.\n\n10\n00:00:23,480 --> 00:00:26,480\nYou suppress the details and\nyou just use the contract,\n\n11\n00:00:26,480 --> 00:00:29,870\nthat specification that says,\nif you give me things that\n\n12\n00:00:29,870 --> 00:00:32,740\nsatisfy certain constraints,\nthis function will give you\n\n13\n00:00:32,740 --> 00:00:35,720\nback answers that meet\nparticular desires.\n\n14\n00:00:35,720 --> 00:00:37,350\nThat's great.\n\n15\n00:00:37,350 --> 00:00:39,800\nBut even functions can come\nin different flavors.\n\n16\n00:00:39,800 --> 00:00:42,560\nAnd there's some real power to\nthinking about different ways\n\n17\n00:00:42,560 --> 00:00:45,280\nof tackling a computational\nproblem.\n\n18\n00:00:45,280 --> 00:00:47,780\nAnd I wanted to spend a little\nbit of time in this section\n\n19\n00:00:47,780 --> 00:00:49,310\ntalking about that.\n\n20\n00:00:49,310 --> 00:00:51,430\nLet's start with what\nwe've seen so far.\n\n21\n00:00:51,430 --> 00:00:54,650\nWe've really been using looping\nconstructs as our way\n\n22\n00:00:54,650 --> 00:00:55,570\nof building algorithms.\n\n23\n00:00:55,570 --> 00:00:58,660\nAnd those looping constructs,\nthings like while loop, a for\n\n24\n00:00:58,660 --> 00:01:02,630\nloop, lead naturally to what we\nwould refer to as iterative\n\n25\n00:01:02,630 --> 00:01:03,230\nalgorithms.\n\n26\n00:01:03,230 --> 00:01:07,080\nThey iterate their way through\nthe loop, going over and over\n\n27\n00:01:07,080 --> 00:01:10,150\nthe same computation with\nslight changes.\n\n28\n00:01:10,150 --> 00:01:13,110\nAnd in particular, we can\nthink of an iterative\n\n29\n00:01:13,110 --> 00:01:16,530\nalgorithm as capturing\ncomputation in a set of what\n\n30\n00:01:16,530 --> 00:01:18,440\nwe could call state variables.\n\n31\n00:01:18,440 --> 00:01:20,500\nThese are variables that\ndescribe the state of the\n\n32\n00:01:20,500 --> 00:01:21,590\ncomputation.\n\n33\n00:01:21,590 --> 00:01:25,010\nAnd those variables update or\nchange their values on each\n\n34\n00:01:25,010 --> 00:01:26,900\niteration through the loop.\n\n35\n00:01:26,900 --> 00:01:29,110\nLet's look at an example.\n\n36\n00:01:29,110 --> 00:01:31,480\nSo here's a simple\nlittle example.\n\n37\n00:01:31,480 --> 00:01:33,990\nImagine that we want to do\nmultiplication, and we're\n\n38\n00:01:33,990 --> 00:01:36,840\ngoing to do it just using\nsuccessive addition.\n\n39\n00:01:36,840 --> 00:01:38,240\nOur computer only comes\nwith addition.\n\n40\n00:01:38,240 --> 00:01:40,170\nIt doesn't come with a\nbuilt in multiply.\n\n41\n00:01:40,170 --> 00:01:42,130\nI know that's dumb, but\nit gives us a simple\n\n42\n00:01:42,130 --> 00:01:43,990\nexample to deal with.\n\n43\n00:01:43,990 --> 00:01:46,690\nIf we wanted to do that, to do\nmultiplication by successive\n\n44\n00:01:46,690 --> 00:01:49,800\nadditions, then a simple way to\nthink about it is to say if\n\n45\n00:01:49,800 --> 00:01:52,840\nwe want to multiply a by b,\nwe're just going to add a to\n\n46\n00:01:52,840 --> 00:01:55,070\nitself b times.\n\n47\n00:01:55,070 --> 00:01:57,300\nAnd iteratively, what\ndoes that mean?\n\n48\n00:01:57,300 --> 00:02:00,650\nLiterally, we could say\ncomputation's going to be\n\n49\n00:02:00,650 --> 00:02:03,080\ncaptured by two variables.\n\n50\n00:02:03,080 --> 00:02:05,110\nOne is the iteration number.\n\n51\n00:02:05,110 --> 00:02:08,430\nWhich time through\nthe loop am I at?\n\n52\n00:02:08,430 --> 00:02:11,020\nThat number, let's call it i,\narbitrarily, is going to\n\n53\n00:02:11,020 --> 00:02:12,960\nstart off at b.\n\n54\n00:02:12,960 --> 00:02:16,100\nAnd the second thing we're\ngoing to need is a state\n\n55\n00:02:16,100 --> 00:02:18,160\nvariable that captures\nhow many additions\n\n56\n00:02:18,160 --> 00:02:18,820\nwe've already done.\n\n57\n00:02:18,820 --> 00:02:20,120\nWhat the result is so far.\n\n58\n00:02:20,120 --> 00:02:21,690\nLet's just call it result.\n\n59\n00:02:21,690 --> 00:02:23,840\nSo that's the current state\nof the computation.\n\n60\n00:02:23,840 --> 00:02:25,460\nAnd that starts off at zero.\n\n61\n00:02:25,460 --> 00:02:28,010\nSo notice, each of these\nstate variables has an\n\n62\n00:02:28,010 --> 00:02:29,080\ninitialization.\n\n63\n00:02:29,080 --> 00:02:30,940\nWe started off somewhere.\n\n64\n00:02:30,940 --> 00:02:34,140\nAnd then we think of the\ncomputation as iterating\n\n65\n00:02:34,140 --> 00:02:36,950\nthrough or updating those\nstate variables.\n\n66\n00:02:36,950 --> 00:02:39,570\nAnd those update rules, in this\ncase, would be that on\n\n67\n00:02:39,570 --> 00:02:44,250\neach iteration i, my iteration\nnumber, is going to reduce by\n\n68\n00:02:44,250 --> 00:02:47,660\none and result, the thing\nthat's holding the\n\n69\n00:02:47,660 --> 00:02:50,820\ncomputation, is going to take\nthe current value of result,\n\n70\n00:02:50,820 --> 00:02:53,870\nadd the value of a to it, and\nthat becomes the new value of\n\n71\n00:02:53,870 --> 00:02:55,470\nthat state variable.\n\n72\n00:02:55,470 --> 00:02:57,960\nSo these state variables have\nthe property that if I stop\n\n73\n00:02:57,960 --> 00:03:00,430\nthe computation at any\npoint, they tell me\n\n74\n00:03:00,430 --> 00:03:02,320\nexactly where I am.\n\n75\n00:03:02,320 --> 00:03:05,590\nAnd they have the property\nthat not only are they\n\n76\n00:03:05,590 --> 00:03:08,000\ninitialized, but at least one of\nthem will have a condition\n\n77\n00:03:08,000 --> 00:03:10,100\nfor telling me when\nI can stop.\n\n78\n00:03:10,100 --> 00:03:12,860\nAnd in this case, I'll stop\nwhen the iteration count\n\n79\n00:03:12,860 --> 00:03:14,090\ngets down to 0.\n\n80\n00:03:14,090 --> 00:03:16,820\nI know I've done all the\nthings I need to do.\n\n81\n00:03:16,820 --> 00:03:19,680\nWe've seen examples like that,\nbut this idea of iteration is\n\n82\n00:03:19,680 --> 00:03:20,920\nnicely captured.\n\n83\n00:03:20,920 --> 00:03:25,020\nAnd if we put it into code, in\nfact, we see something that\n\n84\n00:03:25,020 --> 00:03:27,300\nvery nicely builds on that.\n\n85\n00:03:27,300 --> 00:03:29,980\nWe initialize one\nstate variable.\n\n86\n00:03:29,980 --> 00:03:32,800\nIn this case, we're going to\njust use the parameter passed\n\n87\n00:03:32,800 --> 00:03:34,000\nin as the other state\nvariable.\n\n88\n00:03:34,000 --> 00:03:36,460\nAnd it's initialized when\nit is passed in.\n\n89\n00:03:36,460 --> 00:03:40,680\nAnd then the loop simply\nhas updates.\n\n90\n00:03:40,680 --> 00:03:43,220\nThere's the updating of\nthose state variables.\n\n91\n00:03:43,220 --> 00:03:45,660\nAnd let me make a simple comment\nabout this format,\n\n92\n00:03:45,660 --> 00:03:47,300\nsince we haven't\nused it before.\n\n93\n00:03:47,300 --> 00:03:53,420\nThat format is the same as\nsaying let result be bound to\n\n94\n00:03:53,420 --> 00:03:57,172\nresult plus a.\n\n95\n00:03:57,172 --> 00:04:02,370\nAnd this one is saying let\nb be bound to b minus 1.\n\n96\n00:04:02,370 --> 00:04:04,590\nIt's simple, little shorthand\nfor doing that kind of\n\n97\n00:04:04,590 --> 00:04:05,970\ncomputation.\n\n98\n00:04:05,970 --> 00:04:07,400\nAnd of course, when I'm\ndone, I'm going\n\n99\n00:04:07,400 --> 00:04:10,040\nto return the result.\n\n100\n00:04:10,040 --> 00:04:11,640\nWe've seen these kinds\nof examples before.\n\n101\n00:04:11,640 --> 00:04:14,080\nAnd you can see how iteration's\na nice way of\n\n102\n00:04:14,080 --> 00:04:14,710\nthinking about it.\n\n103\n00:04:14,710 --> 00:04:18,649\nThat loop actually captures what\nthe changes in the state\n\n104\n00:04:18,649 --> 00:04:20,480\nvariables are at each point.\n\n105\n00:04:20,480 --> 00:04:22,070\nAnd if we wanted to try it,\nwe could certainly go\n\n106\n00:04:22,070 --> 00:04:25,830\nover here to Python.\n\n107\n00:04:25,830 --> 00:04:27,980\nAnd there is my definition\nof iterMul.\n\n108\n00:04:27,980 --> 00:04:36,500\nAnd if I load it into an IDLE\nenvironment, then I can\n\n109\n00:04:36,500 --> 00:04:38,990\ncertainly say things like,\ngive me the iterative\n\n110\n00:04:38,990 --> 00:04:42,800\nmultiplication of 3 and 5, and\nit does the right thing.\n\n111\n00:04:42,800 --> 00:04:46,070\nAnd I can even be more fancy\nabout it and say things like--\n\n112\n00:04:46,070 --> 00:04:49,325\n\n113\n00:04:49,325 --> 00:04:51,360\nAnd it does it pretty quickly.\n\n114\n00:04:51,360 --> 00:04:53,350\nWe haven't shown out the\nintermediate stages of the\n\n115\n00:04:53,350 --> 00:04:55,790\nloop, but you've seen enough\nexamples of this to realize\n\n116\n00:04:55,790 --> 00:04:59,030\nthat it is, in fact, doing that\ncounting down of b while\n\n117\n00:04:59,030 --> 00:05:01,060\naccumulating the results\nin result and then\n\n118\n00:05:01,060 --> 00:05:02,770\nreturning the value.\n\n119\n00:05:02,770 --> 00:05:04,020\nGreat.\n\n120\n00:05:04,020 --> 00:05:04,320\n\n"}, "playlist_index": null}